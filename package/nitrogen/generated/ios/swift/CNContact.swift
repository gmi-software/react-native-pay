///
/// CNContact.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

import NitroModules

/**
 * Represents an instance of `CNContact`, backed by a C++ struct.
 */
public typealias CNContact = margelo.nitro.pay.CNContact

public extension CNContact {
  private typealias bridge = margelo.nitro.pay.bridge.swift

  /**
   * Create a new instance of `CNContact`.
   */
  init(identifier: String, contactType: CNContactType, namePrefix: String, givenName: String, middleName: String, familyName: String, previousFamilyName: String, nameSuffix: String, nickname: String, organizationName: String, departmentName: String, jobTitle: String, phoneticGivenName: String, phoneticMiddleName: String, phoneticFamilyName: String, phoneticOrganizationName: String?, note: String, imageDataAvailable: Bool?, phoneNumbers: [CNLabeledPhoneNumber], emailAddresses: [CNLabeledEmailAddress], postalAddresses: [CNLabeledPostalAddress]) {
    self.init(std.string(identifier), contactType, std.string(namePrefix), std.string(givenName), std.string(middleName), std.string(familyName), std.string(previousFamilyName), std.string(nameSuffix), std.string(nickname), std.string(organizationName), std.string(departmentName), std.string(jobTitle), std.string(phoneticGivenName), std.string(phoneticMiddleName), std.string(phoneticFamilyName), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = phoneticOrganizationName {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), std.string(note), { () -> bridge.std__optional_bool_ in
      if let __unwrappedValue = imageDataAvailable {
        return bridge.create_std__optional_bool_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__vector_CNLabeledPhoneNumber_ in
      var __vector = bridge.create_std__vector_CNLabeledPhoneNumber_(phoneNumbers.count)
      for __item in phoneNumbers {
        __vector.push_back(__item)
      }
      return __vector
    }(), { () -> bridge.std__vector_CNLabeledEmailAddress_ in
      var __vector = bridge.create_std__vector_CNLabeledEmailAddress_(emailAddresses.count)
      for __item in emailAddresses {
        __vector.push_back(__item)
      }
      return __vector
    }(), { () -> bridge.std__vector_CNLabeledPostalAddress_ in
      var __vector = bridge.create_std__vector_CNLabeledPostalAddress_(postalAddresses.count)
      for __item in postalAddresses {
        __vector.push_back(__item)
      }
      return __vector
    }())
  }

  var identifier: String {
    @inline(__always)
    get {
      return String(self.__identifier)
    }
    @inline(__always)
    set {
      self.__identifier = std.string(newValue)
    }
  }
  
  var contactType: CNContactType {
    @inline(__always)
    get {
      return self.__contactType
    }
    @inline(__always)
    set {
      self.__contactType = newValue
    }
  }
  
  var namePrefix: String {
    @inline(__always)
    get {
      return String(self.__namePrefix)
    }
    @inline(__always)
    set {
      self.__namePrefix = std.string(newValue)
    }
  }
  
  var givenName: String {
    @inline(__always)
    get {
      return String(self.__givenName)
    }
    @inline(__always)
    set {
      self.__givenName = std.string(newValue)
    }
  }
  
  var middleName: String {
    @inline(__always)
    get {
      return String(self.__middleName)
    }
    @inline(__always)
    set {
      self.__middleName = std.string(newValue)
    }
  }
  
  var familyName: String {
    @inline(__always)
    get {
      return String(self.__familyName)
    }
    @inline(__always)
    set {
      self.__familyName = std.string(newValue)
    }
  }
  
  var previousFamilyName: String {
    @inline(__always)
    get {
      return String(self.__previousFamilyName)
    }
    @inline(__always)
    set {
      self.__previousFamilyName = std.string(newValue)
    }
  }
  
  var nameSuffix: String {
    @inline(__always)
    get {
      return String(self.__nameSuffix)
    }
    @inline(__always)
    set {
      self.__nameSuffix = std.string(newValue)
    }
  }
  
  var nickname: String {
    @inline(__always)
    get {
      return String(self.__nickname)
    }
    @inline(__always)
    set {
      self.__nickname = std.string(newValue)
    }
  }
  
  var organizationName: String {
    @inline(__always)
    get {
      return String(self.__organizationName)
    }
    @inline(__always)
    set {
      self.__organizationName = std.string(newValue)
    }
  }
  
  var departmentName: String {
    @inline(__always)
    get {
      return String(self.__departmentName)
    }
    @inline(__always)
    set {
      self.__departmentName = std.string(newValue)
    }
  }
  
  var jobTitle: String {
    @inline(__always)
    get {
      return String(self.__jobTitle)
    }
    @inline(__always)
    set {
      self.__jobTitle = std.string(newValue)
    }
  }
  
  var phoneticGivenName: String {
    @inline(__always)
    get {
      return String(self.__phoneticGivenName)
    }
    @inline(__always)
    set {
      self.__phoneticGivenName = std.string(newValue)
    }
  }
  
  var phoneticMiddleName: String {
    @inline(__always)
    get {
      return String(self.__phoneticMiddleName)
    }
    @inline(__always)
    set {
      self.__phoneticMiddleName = std.string(newValue)
    }
  }
  
  var phoneticFamilyName: String {
    @inline(__always)
    get {
      return String(self.__phoneticFamilyName)
    }
    @inline(__always)
    set {
      self.__phoneticFamilyName = std.string(newValue)
    }
  }
  
  var phoneticOrganizationName: String? {
    @inline(__always)
    get {
      return { () -> String? in
        if bridge.has_value_std__optional_std__string_(self.__phoneticOrganizationName) {
          let __unwrapped = bridge.get_std__optional_std__string_(self.__phoneticOrganizationName)
          return String(__unwrapped)
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__phoneticOrganizationName = { () -> bridge.std__optional_std__string_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
        } else {
          return .init()
        }
      }()
    }
  }
  
  var note: String {
    @inline(__always)
    get {
      return String(self.__note)
    }
    @inline(__always)
    set {
      self.__note = std.string(newValue)
    }
  }
  
  var imageDataAvailable: Bool? {
    @inline(__always)
    get {
      return { () -> Bool? in
        if bridge.has_value_std__optional_bool_(self.__imageDataAvailable) {
          let __unwrapped = bridge.get_std__optional_bool_(self.__imageDataAvailable)
          return __unwrapped
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__imageDataAvailable = { () -> bridge.std__optional_bool_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_bool_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var phoneNumbers: [CNLabeledPhoneNumber] {
    @inline(__always)
    get {
      return self.__phoneNumbers.map({ __item in __item })
    }
    @inline(__always)
    set {
      self.__phoneNumbers = { () -> bridge.std__vector_CNLabeledPhoneNumber_ in
        var __vector = bridge.create_std__vector_CNLabeledPhoneNumber_(newValue.count)
        for __item in newValue {
          __vector.push_back(__item)
        }
        return __vector
      }()
    }
  }
  
  var emailAddresses: [CNLabeledEmailAddress] {
    @inline(__always)
    get {
      return self.__emailAddresses.map({ __item in __item })
    }
    @inline(__always)
    set {
      self.__emailAddresses = { () -> bridge.std__vector_CNLabeledEmailAddress_ in
        var __vector = bridge.create_std__vector_CNLabeledEmailAddress_(newValue.count)
        for __item in newValue {
          __vector.push_back(__item)
        }
        return __vector
      }()
    }
  }
  
  var postalAddresses: [CNLabeledPostalAddress] {
    @inline(__always)
    get {
      return self.__postalAddresses.map({ __item in __item })
    }
    @inline(__always)
    set {
      self.__postalAddresses = { () -> bridge.std__vector_CNLabeledPostalAddress_ in
        var __vector = bridge.create_std__vector_CNLabeledPostalAddress_(newValue.count)
        for __item in newValue {
          __vector.push_back(__item)
        }
        return __vector
      }()
    }
  }
}
